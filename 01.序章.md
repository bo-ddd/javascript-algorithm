### 序章

> 假设你现在你已经可以正常的开发且能独立的完成业务需求了,此时我们就要不断的思考我们的代码该如何优化了,通常情况下,项目的优化分为很多种,比如打包,压缩,减少http请求等,但我们今天想要说的是提高一个方法的运行速度,通常情况下，想要判断一个方法的好坏，就是看这个方法执行的时间或者说是速度的快慢，比如有如下一个方法:

```javascript
function sum(num){
    let res = 0;
    for(let i = 0; i < num; i++){
        res += num;
    }
    return res;
}
```

上面这个方法是一个非常简单的求和函数，调用时会像是这样：

```javascript
let n1 = sum(3); // 1 + 2 + 3
console.log(n1) // 6 

let n2 = sum(4); // 1 + 2 + 3 + 4
console.log(n2) // 10
```

通常情况下,我们可以利用Date函数中的getTime来获取毫秒数,来测试函数的运行时间,比如像这样:

```javascript
let startTime = new Date().getTime();
sum(40);
let endTime = new Date().getTime();
console.log(endTime - startTime);
```

这样就可以获取出来sum(40)方法运行了多长时间,除此之外,在javascript中,还有一个性能函数(performance),也可以实现,比如像这样:

```javascript
let startTime = performance.now();
sum(40);
let endTime = performance.now();
console.log(endTime - startTime);
```

在这个性能函数(performance)中,其实还有很多很多测试性能的方法,但并不是我们现在该关注的问题,我们可以根据这个函数来在控制台上输出的是一个毫秒数,但你多次刷新浏览器,会发现他每次的值都不太一样,比如像这样:

```javascript
//控制台刷新10次结果值:
0.10000000149011612
0
0.09999999403953552
0.10000000149011612
0
0.09999999403953552
0
0
0.09999999403953552
0.09999999403953552
```

那该函数为什么会出现不同的运行时间呢?其实这个时间是根据我们的电脑的cpu及电脑运行进程数等各方面的原因影响的,也是因为这样,这个数字并不能代表我们的的函数的性能具体怎么样,但是我们修改一下这个函数的入参(将40改成4000)会怎么样呢?

```javascript
let startTime = performance.now();
sum(4000);
let endTime = performance.now();
console.log(endTime - startTime);

//控制台展示的10次结果值:
0.3999999985098839
0.5
0.3999999985098839
0.3999999985098839
0.4000000059604645
0.5
0.3999999985098839
0.3999999985098839
0.5
0.5
```

你会发现,如果你把<code>sum(40)</code>改成 <code>sum(4000)</code>,该函数的运行速度就变长一些,如果我们在把4000改成40000,则会变得更长,为什么会有这种现象呢?我们需要重新来看一下这个方法:

```javascript
sum(3);

//代码从上到下执行,我们把每一行代码,都算成一个运行时间.
function sum(num){
    let res = 0;  // 占用 1 个运行时间
    for(let i = 0; i < num; i++){
        res += num;  // 占用 1 个运行时间, 但是循环了3次,所以占3个运行时间;
    }
    return res; // 占用 1 个运行时间
}

//所以, sum(3) 的运行时间为 1 + 3 + 1 = 5; 一共占用5个运行时间;
//sum(10) 会占用 1 + 10 + 1 = 12;  一共占用 12 个运行时间;
//sum(400) 会占用  1 + 400 + 1 = 402; 一共占用 402 个运行时间;
```

像这种随着入参变大运行时间而一直线性增加的函数,我们统称为这种函数的复杂度为线性复杂度,因为num是一个不确定的值,我们把这个num叫简称为n,所以,这个函数运行的占用运行时间为:

```javascript
1 + n + 1 = 2 + n;
```

又因为n是一个不确定的数字, 并且我们想要测该函数的运行时间也不在乎这一个2 + n中的2,所以我们可以认为,这个函数的复杂度为 n (2可以忽略不计);

在表示时间复杂度时,我们通常会用一个大字字母O来表示,通常会写成:

```javascript
O(n)
```

通常情况下,我们会念成,sum函数的时间复杂度为On(拼音念法为: ou en);

那么比如我们有这样两个函数:

```javascript
// 共占用一个运行时间
function fn(){
    console.log(1);  //占用一个运行时间
}

// 共占用两个运行时间
function fn2(){
    console.log(1); // 占用一个运行时间
    console.log(2); // 占用一个运行时间
}

```

上面两个函数中,分别占用1个运行时间和2个运行时间,按照常理,我们应该写成:

```
fn函数的时间复杂度为: O(1)
fn2函数的时间复杂度为: O(2)
```

但是常量的时间复杂度,本身就没有区别,所以我们通常把这种时间复杂度统一写成:

```
O(1)
```

除了以上讲的两种常见的时间复杂度之外,还会有一些其它的时间复杂度,他们的性能排行从快到慢为:

1. O(1)   
2. O(log n)
3. O(n)
4. O(n<sup>2</sup>)      
5. O(2<sup>n</sup>)

本章节的知识点到这里就结束了哦,本章节的学习目的,

1. 知道如何测试一个方法的运行时间;
2. 了解时间复杂复的概念;
3. 了解时间复杂度的种类;